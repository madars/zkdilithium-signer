#!/usr/bin/env python3
"""
Test vectors for zkdilithium.py

These tests use hardcoded expected values that must be reproduced
exactly by the Go implementation.

TEST VECTOR PROVENANCE
======================
These test vectors were generated by running zkdilithium.py (the reference
Python implementation) and capturing input/output pairs. The generation
process was:

1. Source: zkdilithium.py from https://github.com/guruvamsi-policharla/zkdilithium
2. Run: python generate_test_vectors.py > test_vectors.json
3. The JSON output was used to hardcode expected values into this file

To regenerate vectors (e.g., if implementation changes):
    source .venv/bin/activate
    python generate_test_vectors.py > test_vectors.json

For the Go port, implement each component and verify it produces identical
outputs for the same inputs. Test classes are organized by component to
allow incremental porting:

    TestConstants       -> pkg/field/constants.go
    TestModularInverse  -> pkg/field/arithmetic.go
    TestBitReversal     -> pkg/ntt/bitrev.go
    TestXOF             -> pkg/hash/xof.go (uses crypto/sha3)
    TestBytesToFes      -> pkg/encoding/bytes.go
    TestPackFes         -> pkg/encoding/pack.go
    TestDecompose       -> pkg/field/decompose.go
    TestCubic           -> pkg/field/cubic.go
    TestNTT             -> pkg/ntt/ntt.go
    TestSchoolbookMul   -> pkg/poly/schoolbook.go
    TestPoseidon        -> pkg/hash/poseidon.go
    TestGrain           -> pkg/hash/grain.go
    TestSampling        -> pkg/sampling/*.go
    TestKeyGeneration   -> pkg/dilithium/keygen.go
    TestSignature       -> pkg/dilithium/sign.go, verify.go

Key insight: if all component tests pass with the same hardcoded values,
the full Sign/Verify will work correctly.
"""

import pytest
from zkdilithium import (
    # Constants
    Q, N, ZETA, INVZETA, INV2, ZETAS, INVZETAS,
    GAMMA1, GAMMA2, ETA, K, L, TAU, BETA,
    POS_T, POS_RATE, POS_RF, POS_RCS,
    # Functions
    inv, brv, decompose,
    packFes, unpackFes,
    bytesToFes,
    XOF128, XOF256, H,
    poseidon_perm,
    sampleUniform, sampleLeqEta, sampleInBall,
    # Classes
    Cubic, Poly, Vec, Poseidon, Grain,
    Gen, Sign, Verify,
)


class TestConstants:
    """Verify constants match expected values."""

    def test_q(self):
        assert Q == 7340033

    def test_n(self):
        assert N == 256

    def test_zeta(self):
        assert ZETA == 3483618

    def test_invzeta(self):
        assert INVZETA == 3141965

    def test_inv2(self):
        assert INV2 == 3670017

    def test_gamma1(self):
        assert GAMMA1 == 131072

    def test_gamma2(self):
        assert GAMMA2 == 65536

    def test_dilithium_params(self):
        assert ETA == 2
        assert K == 4
        assert L == 4
        assert TAU == 40
        assert BETA == 80

    def test_poseidon_params(self):
        assert POS_T == 35
        assert POS_RATE == 24
        assert POS_RF == 21

    def test_zetas_first16(self):
        expected = [
            2306278, 2001861, 3926523, 5712452, 1922517, 5680261, 4961214, 7026628,
            3353052, 3414003, 1291800, 3770003, 2188519, 44983, 6616885, 4899906
        ]
        assert ZETAS[:16] == expected

    def test_invzetas_first16(self):
        expected = [
            3141965, 4642089, 4848144, 7181330, 1276293, 6226173, 6371478, 1545565,
            5830703, 4663853, 2915060, 2998944, 5640911, 2250107, 6697852, 5413710
        ]
        assert INVZETAS[:16] == expected


class TestModularInverse:
    """Test modular inverse with known input/output pairs."""

    def test_inv_1(self):
        assert inv(1) == 1

    def test_inv_2(self):
        assert inv(2) == 3670017

    def test_inv_3(self):
        assert inv(3) == 2446678

    def test_inv_1000(self):
        assert inv(1000) == 2224030

    def test_inv_q_minus_1(self):
        assert inv(Q - 1) == 7340032

    def test_inv_123456(self):
        assert inv(123456) == 2165041


class TestBitReversal:
    """Test bit reversal with known input/output pairs."""

    def test_brv_0(self):
        assert brv(0) == 0

    def test_brv_1(self):
        assert brv(1) == 128

    def test_brv_2(self):
        assert brv(2) == 64

    def test_brv_127(self):
        assert brv(127) == 254

    def test_brv_128(self):
        assert brv(128) == 1

    def test_brv_255(self):
        assert brv(255) == 255

    def test_brv_170(self):
        assert brv(170) == 85


class TestXOF:
    """Test XOF functions with known input/output pairs."""

    def test_xof128_zeros(self):
        stream = XOF128(bytes.fromhex('00' * 32), 0)
        expected = bytes.fromhex('49dfd9809bbc54014aabcc6a9a19f5ed48ad57d91902917201b689782ac6c75e')
        assert stream.read(32) == expected

    def test_xof128_with_data(self):
        stream = XOF128(bytes.fromhex('abcd' + '00' * 30), 42)
        expected = bytes.fromhex('c284856075f7c4b04817d544b48d792c4793f2ce1215f04c812c58f9609617e1')
        assert stream.read(32) == expected

    def test_xof256_zeros(self):
        stream = XOF256(bytes.fromhex('00' * 64), 0)
        expected = bytes.fromhex('4c838207f7a3088bf011c6d221a172bff9257c8f4b807ba9d4c851fd20263efb')
        assert stream.read(32) == expected

    def test_h_shake256(self):
        result = H(b'test', 32)
        expected = bytes.fromhex('b54ff7255705a71ee2925e4a3e30e41aed489a579d5595e0df13e32e1e4dd202')
        assert result == expected


class TestBytesToFes:
    """Test bytesToFes with known input/output pairs."""

    def test_two_zeros(self):
        assert bytesToFes(bytes([0, 0])) == [258]

    def test_single_byte(self):
        assert bytesToFes(bytes([5])) == [6]

    def test_two_ff(self):
        assert bytesToFes(bytes([0xff, 0xff])) == [66048]

    def test_hello(self):
        assert bytesToFes(b'hello') == [26319, 28122, 112]


class TestPackFes:
    """Test packFes/unpackFes with known values."""

    def test_pack_known_values(self):
        fes = [0, 1, 100, 1000, 7340032, 3670016]
        expected = bytes.fromhex('000000010000640000e80300000070000038')
        assert packFes(fes) == expected

    def test_roundtrip(self):
        fes = [0, 1, 100, 1000, 7340032, 3670016]
        assert unpackFes(packFes(fes)) == fes


class TestDecompose:
    """Test decompose with known input/output pairs."""

    def test_decompose_0(self):
        assert decompose(0) == (0, 0)

    def test_decompose_1(self):
        assert decompose(1) == (1, 0)

    def test_decompose_gamma2(self):
        assert decompose(65536) == (65536, 0)

    def test_decompose_2gamma2(self):
        assert decompose(131072) == (0, 1)

    def test_decompose_q_minus_1(self):
        assert decompose(7340032) == (-1, 0)

    def test_decompose_q_minus_gamma2(self):
        assert decompose(7274497) == (-65536, 0)

    def test_decompose_q_half(self):
        assert decompose(3670016) == (0, 28)

    def test_decompose_12345(self):
        assert decompose(12345) == (12345, 0)

    def test_decompose_q_minus_12345(self):
        assert decompose(7327688) == (-12345, 0)


class TestCubic:
    """Test Cubic field arithmetic with known values."""

    def test_cubic_add(self):
        a = Cubic(100, 200, 300)
        b = Cubic(400, 500, 600)
        result = a + b
        assert (result.a0, result.a1, result.a2) == (500, 700, 900)

    def test_cubic_mul(self):
        a = Cubic(100, 200, 300)
        b = Cubic(400, 500, 600)
        result = a * b
        assert (result.a0, result.a1, result.a2) == (310000, 40000, 100000)


class TestNTT:
    """Test NTT with known input/output pairs."""

    def test_ntt_of_one(self):
        """NTT([1,0,0,...]) should be [1,1,1,...]"""
        p = Poly([1] + [0] * 255)
        result = p.NTT()
        assert all(c == 1 for c in result.cs)

    def test_ntt_of_range_first16(self):
        p = Poly(range(256))
        result = p.NTT()
        expected = [
            2754782, 330900, 3925693, 7072021, 2466426, 6834207, 295586, 3288141,
            173314, 532343, 1598161, 7075758, 3213908, 3140407, 336540, 5680828
        ]
        assert list(result.cs[:16]) == expected

    def test_ntt_of_range_last16(self):
        p = Poly(range(256))
        result = p.NTT()
        expected = [
            1985751, 2796981, 2604241, 4522247, 1647302, 1983575, 6357638, 1452416,
            542738, 3830297, 4720115, 1538039, 4911108, 5764199, 1590910, 2423889
        ]
        assert list(result.cs[-16:]) == expected

    def test_ntt_roundtrip(self):
        p = Poly(range(256))
        assert p.NTT().InvNTT() == p


class TestSchoolbookMul:
    """Test schoolbook multiplication with known values."""

    def test_schoolbook_mul_result_first16(self):
        a = Poly(list(range(256)))
        b = Poly(list(range(256, 512)))
        q, r = a.SchoolbookMul(b)
        expected = [
            3528066, 3496194, 3465092, 3434762, 3405206, 3376426, 3348424, 3321202,
            3294762, 3269106, 3244236, 3220154, 3196862, 3174362, 3152656, 3131746
        ]
        assert list(r.cs[:16]) == expected

    def test_schoolbook_mul_result_last16(self):
        a = Poly(list(range(256)))
        b = Poly(list(range(256, 512)))
        q, r = a.SchoolbookMul(b)
        expected = [
            492847, 703135, 914673, 1127463, 1341507, 1556807, 1773365, 1991183,
            2210263, 2430607, 2652217, 2875095, 3099243, 3324663, 3551357, 3779327
        ]
        assert list(r.cs[-16:]) == expected

    def test_schoolbook_mul_quotient_first16(self):
        a = Poly(list(range(256)))
        b = Poly(list(range(256, 512)))
        q, r = a.SchoolbookMul(b)
        expected = [
            3811967, 3844095, 3875710, 3906811, 3937397, 3967467, 3997020, 4026055,
            4054571, 4082567, 4110042, 4136995, 4163425, 4189331, 4214712, 4239567
        ]
        assert list(q.cs[:16]) == expected

    def test_ntt_mul_matches_schoolbook(self):
        """NTT multiplication should match schoolbook result."""
        a = Poly(range(256))
        b = Poly(range(256, 512))
        _, r_school = a.SchoolbookMul(b)
        r_ntt = a.NTT().MulNTT(b.NTT()).InvNTT()
        assert r_ntt == r_school


class TestPoseidon:
    """Test Poseidon hash with known values."""

    def test_poseidon_perm(self):
        state = list(range(POS_T))
        poseidon_perm(state)
        expected = [
            6525793, 2817790, 5538989, 1140645, 1838881, 2536727, 6768730, 4709337,
            6955613, 2401101, 1387526, 5346661, 1137806, 7270459, 1552970, 4071298,
            3931520, 4509604, 1434920, 2477273, 4595089, 4960924, 2665912, 5601770,
            3176785, 6236514, 4336216, 2469459, 2737160, 6481909, 5295937, 1830143,
            7322777, 3396423, 2354672
        ]
        assert state == expected

    def test_poseidon_sponge(self):
        h = Poseidon([1, 2, 3])
        result = h.read(12)
        expected = [
            1948781, 4026402, 5373296, 2459025, 3075965, 1506296,
            229209, 7105271, 5926873, 2350085, 6176282, 5229836
        ]
        assert result == expected


class TestGrain:
    """Test Grain LFSR with known values."""

    def test_grain_first10_fes(self):
        g = Grain()
        result = [g.readFe() for _ in range(10)]
        expected = [
            662000, 7104925, 2304656, 2330809, 452951,
            1722141, 5334010, 7087604, 5110463, 6023804
        ]
        assert result == expected

    def test_pos_rcs_first16(self):
        """Round constants should match Grain output."""
        expected = [
            662000, 7104925, 2304656, 2330809, 452951, 1722141, 5334010, 7087604,
            5110463, 6023804, 3061965, 6087945, 3740272, 284272, 4421217, 559188
        ]
        assert POS_RCS[:16] == expected


class TestSampling:
    """Test sampling functions with known values."""

    def test_sample_uniform_first16(self):
        p = sampleUniform(XOF128(bytes(32), 0))
        expected = [
            5889865, 3971968, 4850004, 6999211, 2967789, 1694039, 636417, 4598392,
            7167687, 1092265, 3028014, 5070791, 5596185, 3786936, 6256060, 5896089
        ]
        assert list(p.cs[:16]) == expected

    def test_sample_uniform_last16(self):
        p = sampleUniform(XOF128(bytes(32), 0))
        expected = [
            1649304, 4661824, 3620918, 6844818, 2645999, 3739555, 3888682, 4274156,
            6815638, 3786571, 4509883, 4371144, 2001635, 1862166, 3110494, 3082926
        ]
        assert list(p.cs[-16:]) == expected

    def test_sample_leq_eta_first16(self):
        p = sampleLeqEta(XOF256(bytes(64), 0))
        # Note: negative values are stored as Q-|value|
        expected = [0, 7340031, 7340032, 7340032, 0, 7340032, 0, 2,
                    0, 7340032, 2, 7340032, 2, 1, 7340032, 2]
        assert list(p.cs[:16]) == expected

    def test_sample_in_ball(self):
        """Test sampleInBall produces expected non-zero positions."""
        h = Poseidon([2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
        c = sampleInBall(h)
        assert c is not None

        # Count non-zero coefficients
        nonzero = [(i, c.cs[i]) for i in range(256) if c.cs[i] != 0]
        assert len(nonzero) == 40

        # Check first 10 positions and values
        expected_positions = [11, 17, 24, 42, 50, 51, 57, 58, 61, 70]
        expected_values = [1, 1, 1, 7340032, 7340032, 7340032, 1, 7340032, 7340032, 7340032]
        for i in range(10):
            assert nonzero[i][0] == expected_positions[i]
            assert nonzero[i][1] == expected_values[i]


class TestKeyGeneration:
    """Test key generation with known seed."""

    def test_keygen_sizes(self):
        pk, sk = Gen(bytes(32))
        assert len(pk) == 3104
        assert len(sk) == 3936

    def test_keygen_pk_prefix(self):
        pk, sk = Gen(bytes(32))
        expected = bytes.fromhex('f5977c8283546a63723bc31d2619124f11db4658643336741df81757d5ad3062')
        assert pk[:32] == expected

    def test_keygen_pk_32_to_64(self):
        pk, sk = Gen(bytes(32))
        expected = bytes.fromhex('70bb4539916e957a230b273b97c81553730160dd5f59520815b15c2500087705')
        assert pk[32:64] == expected

    def test_keygen_sk_prefix(self):
        pk, sk = Gen(bytes(32))
        expected = bytes.fromhex('f5977c8283546a63723bc31d2619124f11db4658643336741df81757d5ad3062')
        assert sk[:32] == expected


class TestSignature:
    """
    Test signing with known values.

    THIS IS THE MOST IMPORTANT TEST CLASS.

    If the Go implementation produces byte-for-byte identical signatures
    for the same (seed, message) pair, then all internal components are
    working correctly. The full signature hex below is the gold standard.
    """

    # The canonical test signature: Sign(Gen(bytes(32))[1], b'test')
    # This is deterministic and must be reproduced exactly by Go.
    EXPECTED_SIGNATURE_HEX = (
        "58044167cc06656d0434e13745b66aacdc0642b03eda3361239105618a292dc8"
        "6cbb5f06b3e1abc9ec5243404288a88f212756e3cfd58b6bbc1660a935a11346"
        "315559f1186a10d538c6c9a062dadd9f27457c7a94b7f33e2651a1fbee0730eb"
        "7dba2aa94fc8fced86bdb9301c67175893708124d1f5744aa047b9711f29335e"
        "46e0734497d3be5863fb9b04ffb06789df7ff7d6cd7199d4c0da514e9ab8d3e0"
        "fafc306ca63484f890b0d5c2ddc9a79fbd5780e404b5404dc6ad3b67603781a6"
        "5ec579d3c3d88d05f8367fec9af15157b68c070bf6217e18947f016a29aa17d1"
        "337c484edec8cd00b502e80c910c27bd818840116417d63230bf06ac28c14e71"
        "90347db275326c857431e01694f7c2fdec2c0d5044521aaa23ecec21d9062b3a"
        "be58fe85f52e481ef2c851bc4590374d87c04ca398a2b873683a326ef110f4c3"
        "2d1d9f0f61e9ae4f916752253a8c636dbf92e312e74d7b35f9e4723b78cfaae9"
        "acb435e8f653ab96b1e6044247b6ddb2bbd9fe5993eb07b24edb8849a80d853b"
        "5e44e2cc573cd53f74b89b72930770f934ec2e55c7a9a9e90a5c639f99bcbb37"
        "ded70e157054d18b55cf62da928c027ca40543dcba2f8402020f6e853bad08ce"
        "ce700c56df0efe32226383fd827c31033be01adfa19b41d2bf855bc081d450db"
        "d46a4ddc12cbcd4a7e27ff48076f19342f9b1344625fbbe557c1215748abdbf6"
        "4b00d6cc9c17519a725c90accc3abb4939a800a847dc92bb77764e5795eea103"
        "bfe284b5dae13028b258c4e42310275485d83372e7ec5f931a8b9eb5387afc51"
        "90dc73665991a7aedc11281c9bcf986ad90d5a96db50ab762ef37adb9f635478"
        "5c4e0fc823a05378de71f6112aff61475fca5e17c034ffb4fe7b3330015fc7b2"
        "f80909e8e0365dc93635869bb6ceb9940c1b36796a097cce205de0b5a43d8c1d"
        "76263eabc72bdb2bc2d19e03ad3a2cabc702965b6e186629cf94963455456730"
        "088bbf656388825e7bc1ef14d9ad428bb8d204a9e7d665163a06518cdd16d688"
        "5fbea215c6e30e60a98766931cfcacad9793ea64e6b71a4b6bb4fb7d24cfcfa8"
        "de0ece9e794173195592caa615659221407a8daa5dffac94861dea2c960a608b"
        "58b490fcff361661727bd45c9d0bf6907cc07176cc6304d27119f3c8aaa24351"
        "87e88f35082ff43dd9e8ed82b7f0c6882df00ac0c59f2c9f739ea3e36513830f"
        "b758f244ad5fffe55a18f633b76a2b697ab1b09c90b8f07f35355b23ebecb55a"
        "d987f6b31334525af1bfa0fe4d6756fdbf24de831725201f87d93ba6b370aaf2"
        "028050b09b855d1f5c3e8ed1f3e82fe0315c28bf26a0078cb2d2570d4c18f591"
        "ebc78744815d334601b26efb56ec9d8e4c719ef8eb3cf2aa97168449877610e3"
        "fb4a4d683b54741e2c24cc67d6f8822ba9e26bfff8cc626de1a41b2309b3ee1f"
        "88fd2cf9bc122b3c085bfef553310991d6e1f75d04f1e1192451c383b4b6e525"
        "9a1bfba1f4024915e5dc97dffdf9a8de4a1925b1c71adee0415e5989cc3cf1ed"
        "185a99c69835cbd7e44e873e9b4ef0b9ac20e99e733fb78387b31d020c41ded2"
        "90e61cbe3d34881a44b21b308a46b964799338cba84514ccb7d913cb0be3c658"
        "95abb22764a78ac1d8b97de23dea60ca075bf6cc2d7e63a515589756579242e7"
        "fec1f954ec04da9db5447f4b6af584e6b1f9068d1388baea3785895b5bc6a4fc"
        "f8ee9daaa8b58e0bfc541182be3b5f86d916bf245bacffe59d0e45ded99554ec"
        "5ba11e0556120290d848da3ef6e1f6a4e320c76b7dd94e0c0cc0aae619121354"
        "c173c0eac11abc288b9a83be69a5d6ee86bafd5f1ccc36c85db6503cf42530d3"
        "24eae1e18b5b366222147a87fa43e6bf6f5f25da0802e3ed1ccab404b556f837"
        "1a784644ad8a8f91c28091b533f5613cbb99b0b08ead8bf2a71d38e42751ca90"
        "b1e0e0cc9421b9c4e56fa73b90fd4f3975af1330ec8bf19450880bc38d83ac19"
        "00d4de876a0728dc13b2bbe1c55c2e9eb14dcdcbdfef8ff0933e72ec3c4d60ae"
        "8b893254f96e1c83613da6f572accdf02005e44e3d5a580ac43dd523931bf753"
        "1546934ec60c355555fbc7ad547ad4b27bc940def5885455fcc31178467c3999"
        "cbcd40d0d192bf24705b42f62bdaba625e8c50f821e9b6a186deea5926ca0db4"
        "836b8dac3f22ce18e0eb1672bec29178d49e5a15a36a7ad34893b9b35f1e2d1e"
        "827da27e41e48e65f73c66dfee29a72814acc3a49d4c2a334bf6356aa5491aef"
        "0b0f113bb4dd9431029b89163878b09e76ef6c94ede081f70ab949e695826c2e"
        "6fc038a5c2d0a42c26e960157555e41dd759e8bc5f0feb3ca03cf8bb1f53c7b0"
        "abe05dafaca49f763966d48dc499128cfca0e2c0b8ebfd505d0df94adcfa8dd7"
        "05bde8e84106f59fa4dd809355f202a4620e41979ec315aecb495e589034faaa"
        "4f44c46cd7cdd22c48e7a9d94d12c14d35f7c4b3ccb1cdc30add827efc505167"
        "fcfebb8de3fb79910199203decc077521ae4dec85d8a5922cb19a9821bcf332c"
        "9784e7c84aa72ef901140011d8aa10bc54dd44f4b680907d15b3aa755cd97f53"
        "1fd30d81368587090382031bd90a0460a7a492ca9379b0d628e72608d688bb9c"
        "e33b30a9f457922eac80786951b601d9c91f0d5c36baf7810b2a88a16a5cd535"
        "4b441162b8cebe6fe50bbacf691b8526c60987641b87813d4bb867c5c57a4e0d"
        "10d0e2795cc4a1ab325d43ae0dc02f1a64319c2516f0eb0e106e7d5b62c485ad"
        "fc6a1cc0c9e8417d55469b49bb4f92ce0b2acc0b34245d33738b8689b2190ca2"
        "4438c01d8552776fb5b0bac994fb60654a6e03ae36215fa00384d3f103eebad7"
        "cabc8c21f0069c112daf88981556e009609d173d9b41e13ab7bb050f1862ba8f"
        "3f417b7987a5c19d660b065b07e456ed4de9c5e958676cdaba2642ec93c97cff"
        "b1d25362a16ded7b6e258c6b5158a050c770245cf0813ccbc06ab581ffa26df2"
        "35e51fd506b4d33a20007d19311f7c1628875d8588d0cd571d063a9389839fbe"
        "b18e3d362fe64c55c9116ca5fa756a4c30f1f3f27f1a11cc5f9389b8905cb62d"
        "15feb4fcff349e035acbc07908cb5f6dc2384a70b8a79518bc0bf9dbbba23106"
        "b1a7c64fa95535d04be9dee69b187bbfcb9519cb2fae8b2fcd326cb94360521364"
        "b9422035c25a0e3045fc457399e5f21ac207e62b176210ff49b19d519d192623"
        "b7efb81dfd6f86f0135b8e7e1330f6b2c3e60d98f91e1ebe57191305e9f9b4e1"
        "4959417760a2915deaf5772f3773dccd616a0fcf290afaffb8a2796c9de80814"
        "9f4679"
    )

    def test_sign_full_signature(self):
        """
        THE GOLD STANDARD TEST.

        If this passes in Go, the port is correct.
        """
        pk, sk = Gen(bytes(32))
        sig = Sign(sk, b'test')
        assert sig.hex() == self.EXPECTED_SIGNATURE_HEX

    def test_sign_size(self):
        pk, sk = Gen(bytes(32))
        sig = Sign(sk, b'test')
        assert len(sig) == 2340

    def test_sign_is_deterministic(self):
        """Same inputs must always produce same signature."""
        pk, sk = Gen(bytes(32))
        sig1 = Sign(sk, b'test')
        sig2 = Sign(sk, b'test')
        assert sig1 == sig2

    def test_verify_valid(self):
        pk, sk = Gen(bytes(32))
        sig = Sign(sk, b'test')
        assert Verify(pk, b'test', sig) is True

    def test_verify_wrong_message(self):
        pk, sk = Gen(bytes(32))
        sig = Sign(sk, b'test')
        assert Verify(pk, b'wrong', sig) is False

    def test_verify_corrupted_sig(self):
        pk, sk = Gen(bytes(32))
        sig = Sign(sk, b'test')
        corrupted = bytearray(sig)
        corrupted[0] ^= 0xFF
        assert Verify(pk, b'test', bytes(corrupted)) is False


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
